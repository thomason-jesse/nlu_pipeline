#imperative
check :- (M/PP)/PP : lambda x:p.(lambda y:l.(searchroom(x,y)))
search :- (M/PP)/PP : lambda x:p.(lambda y:l.(searchroom(x,y)))
look :- (M/PP)/PP : lambda x:p.(lambda y:l.(searchroom(x,y)))

bring :- (M/PP)/NP : lambda y:i.(lambda x:p.(bring(y,x)))
deliver :- (M/PP)/NP : lambda y:i.(lambda x:p.(bring(y,x)))
give :- (M/NP)/N : lambda x:p.(lambda y:i.(bring(y,x)))
give :- (M/NP)/NP : lambda x:p.(lambda y:i.(bring(y,x)))
get :- (M/PP)/NP : lambda y:i.(lambda x:p.(bring(y,x)))
take :- (M/PP)/NP : lambda y:i.(lambda x:p.(bring(y,x)))

walk :- M/PP : lambda x:l.(walk(x))
go :- M/PP : lambda x:l.(walk(x)) 
needed :- M/PP : lambda x:l.(walk(x))

#prepositional arguments to commands
for :- PP/N : lambda x:p.(x)
for :- PP/NP : lambda x:p.(x)
whether :- PP/N : lambda x:p.(x)
whether :- PP/NP : lambda x:p.(x)
in :- PP/N : lambda x:l.(x)
is :- PP/PP : lambda x:l.(x)
at :- PP/NP : lambda x:l.(x)
if :- PP/N : lambda x:p.(x)
if :- PP/NP : lambda x:p.(x)

to :- PP/N : lambda x:p.(x)
to :- PP/NP : lambda x:p.(x)
to :- PP/N : lambda x:l.(x)
to :- PP/NP : lambda x:l.(x)

#Vaccous statements. 
i want :- M/M : lambda x:a.(x)
you to :- M/M : lambda x:a.(x)
go and :- M/M : lambda x:a.(x)
you are :- M/M : lambda x:a.(x)
please :- M/M : lambda x:a.(x)
please go :- M/M : lambda x:a.(x)
could you :- M/M : lambda x:a.(x)

#these are weird now bc there's some implicit knowledge in hasoffice that the second arg is an office
's office :- NP\N : lambda x:p.(the(lambda y:l.(and(office(y), possesses(y,x)))))

#closed category
the :- NP/N : lambda x:p.(x)
the :- NP/N : lambda x:i.(x)

a :- NP/N : lambda P:<i,t>.(a(lambda x:i.(P(x))))

# room atoms
room :- N/N : lambda x:l.(x) 
				
3516 :- N : l3_516
3508 :- N : l3_508
3512 :- N : l3_512
3510 :- N : l3_510
3402 :- N : l3_402
3418 :- N : l3_418
3420 :- N : l3_420
3432 :- N : l3_432
3502 :- N : l3_502
3414 b :- N : l3_414b

# people atoms
bruce :- N : bruce
bruce porter :- N : bruce
porter :- N : bruce
stacy :- N : stacy
dana :- N : dana
jivko :- N : jivko
peter :- N : peter
peter stone :- N : peter
stone :- N : peter
ray :- N : ray
mooney :- N : ray
shiqi :- N : shiqi
scott :- N : scott
jesse :- N : jesse
aishwarya :- N : aishwarya
rudy :- N : rodolfo
corona :- N : rodolfo
rodolfo corona :- N : rodolfo
niekum :- N : scott

#People titles. 
mr :- N/N : lambda x:p.(x)
professor :- N/N : lambda x:p.(x)
doctor :- N/N : lambda x:p.(x)
dr :- N/N : lambda x:p.(x)

#Particular people titles. 
grad student :- N : jesse

# item atoms
apple :- N : apple
basket :- N : basket
beverage :- N : beverage
binder :- N : binder
bread :- N : bread
cake :- N : cake
calendar :- N : calendar
coke :- N : coke
cupcake :- N : cupcake
dessert :- N : dessert
doritos :- N : doritos
glass :- N : glass
hamburger :- N : hamburger
hammer :- N : hammer
juice :- N : juice
ledger :- N : ledger
letter :- N : letter
milk :- N : milk
muffin :- N : muffin
organizer :- N : organizer
pencil :- N : pencil
phone :- N : phone
pillow :- N : pillow
pizza :- N : pizza
salad :- N : salad
sandwich :- N : sandwich
snack :- N : snack
tea :- N : tea
trashcan :- N : trashcan
watch :- N : watch

# Predicate adjectival nouns.
ball :- N : lambda x:i.(ball(x))
beans :- N : lambda x:i.(beans(x))
book :- N : lambda x:i.(book(x))
bottle :- N : lambda x:i.(bottle(x))
box :- N : lambda x:i.(box(x))
bucket :- N : lambda x:i.(bucket(x))
can :- N : lambda x:i.(can(x))
canister :- N : lambda x:i.(canister(x))
cap :- N : lambda x:i.(cap(x))
carton :- N : lambda x:i.(carton(x))
cellphone :- N : lambda x:i.(cellphone(x))
chips :- N : lambda x:i.(chips(x))
container :- N : lambda x:i.(container(x))
crayon :- N : lambda x:i.(crayon(x))
cup :- N : lambda x:i.(cup(x))
cylinder :- N : lambda x:i.(cylinder(x))
diary :- N : lambda x:i.(diary(x))
drink :- N : lambda x:i.(drink(x))
flask :- N : lambda x:i.(flask(x))
floaty :- N : lambda x:i.(floaty(x))
jar :- N : lambda x:i.(jar(x))
laptop :- N : lambda x:i.(laptop(x))
lid :- N : lambda x:i.(lid(x))
marker :- N : lambda x:i.(marker(x))
mug :- N : lambda x:i.(mug(x))
notebook :- N : lambda x:i.(notebook(x))
object :- N : lambda x:i.(object(x))
pineapple :- N : lambda x:i.(pineapple(x))
plush-toy :- N : lambda x:i.(plush-toy(x))
prism :- N : lambda x:i.(prism(x))
rectangle :- N : lambda x:i.(rectangle(x))
roll :- N : lambda x:i.(roll(x))
shaker :- N : lambda x:i.(shaker(x))
sphere :- N : lambda x:i.(sphere(x))
spray :- N : lambda x:i.(spray(x))
spraycan :- N : lambda x:i.(spraycan(x))
stuffed-animal :- N : lambda x:i.(stuffed-animal(x))
thing :- N : lambda x:i.(thing(x))
tin :- N : lambda x:i.(tin(x))
tub :- N : lambda x:i.(tub(x))
tube :- N : lambda x:i.(tube(x))
wipes :- N : lambda x:i.(wipes(x))

# Adjective predicates.
aerosol :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), aerosol(x))))
aluminum :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), aluminum(x))))
big :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), big(x))))
black :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), black(x))))
blue :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), blue(x))))
bright :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), bright(x))))
brown :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), brown(x))))
cardboard :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), cardboard(x))))
circular :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), circular(x))))
clear :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), clear(x))))
closed :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), closed(x))))
coffee :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), coffee(x))))
colored :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), colored(x))))
cream-colored :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), cream-colored(x))))
curvy :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), curvy(x))))
cylindrical :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), cylindrical(x))))
empty :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), empty(x))))
fat :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), fat(x))))
foam :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), foam(x))))
foamy :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), foamy(x))))
full :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), full(x))))
gray :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), gray(x))))
green :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), green(x))))
half-full :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), half-full(x))))
heavy :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), heavy(x))))
hollow :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), hollow(x))))
large :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), large(x))))
light :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), light(x))))
liquid :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), liquid(x))))
medium-sized :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), medium-sized(x))))
metal :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), metal(x))))
metallic :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), metallic(x))))
narrow :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), narrow(x))))
neon :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), neon(x))))
open :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), open(x))))
orange :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), orange(x))))
orange-topped :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), orange-topped(x))))
paper :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), paper(x))))
pencil-shaped :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), pencil-shaped(x))))
pink :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), pink(x))))
plastic :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), plastic(x))))
pointed :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), pointed(x))))
pointy :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), pointy(x))))
purple :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), purple(x))))
rectangular :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), rectangular(x))))
red :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), red(x))))
rough :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), rough(x))))
round :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), round(x))))
shiny :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), shiny(x))))
short :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), short(x))))
silent :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), silent(x))))
silver :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), silver(x))))
skinny :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), skinny(x))))
small :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), small(x))))
soft :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), soft(x))))
soup :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), soup(x))))
spherical :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), spherical(x))))
spiky :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), spiky(x))))
squishy :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), squishy(x))))
styrofoam :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), styrofoam(x))))
tall :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), tall(x))))
teal :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), teal(x))))
thin :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), thin(x))))
tiny :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), tiny(x))))
top :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), top(x))))
transparent :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), transparent(x))))
water :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), water(x))))
white :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), white(x))))
wide :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), wide(x))))
yellow :- N/N : lambda P:<i,t>.(lambda x:i.(and(P(x), yellow(x))))
