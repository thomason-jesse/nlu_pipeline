<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="strfuncs_8c" kind="file">
    <compoundname>strfuncs.c</compoundname>
    <includes local="no">stdio.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">assert.h</includes>
    <includes local="no">stdarg.h</includes>
    <includes refid="ckd__alloc_8h" local="yes">sphinxbase/ckd_alloc.h</includes>
    <includes refid="strfuncs_8h" local="yes">sphinxbase/strfuncs.h</includes>
    <incdepgraph>
      <node id="2361">
        <label>stdarg.h</label>
      </node>
      <node id="2365">
        <label>sphinxbase/prim_type.h</label>
        <link refid="prim__type_8h"/>
        <childnode refid="2366" relation="include">
        </childnode>
      </node>
      <node id="2360">
        <label>assert.h</label>
      </node>
      <node id="2367">
        <label>sphinxbase/strfuncs.h</label>
        <link refid="strfuncs_8h"/>
        <childnode refid="2361" relation="include">
        </childnode>
        <childnode refid="2364" relation="include">
        </childnode>
        <childnode refid="2365" relation="include">
        </childnode>
      </node>
      <node id="2358">
        <label>stdlib.h</label>
      </node>
      <node id="2363">
        <label>setjmp.h</label>
      </node>
      <node id="2362">
        <label>sphinxbase/ckd_alloc.h</label>
        <link refid="ckd__alloc_8h"/>
        <childnode refid="2358" relation="include">
        </childnode>
        <childnode refid="2363" relation="include">
        </childnode>
        <childnode refid="2364" relation="include">
        </childnode>
        <childnode refid="2365" relation="include">
        </childnode>
      </node>
      <node id="2366">
        <label>sphinx_config.h</label>
      </node>
      <node id="2359">
        <label>string.h</label>
      </node>
      <node id="2364">
        <label>sphinxbase/sphinxbase_export.h</label>
        <link refid="sphinxbase__export_8h_source"/>
      </node>
      <node id="2356">
        <label>src/libsphinxbase/util/strfuncs.c</label>
        <link refid="strfuncs.c"/>
        <childnode refid="2357" relation="include">
        </childnode>
        <childnode refid="2358" relation="include">
        </childnode>
        <childnode refid="2359" relation="include">
        </childnode>
        <childnode refid="2360" relation="include">
        </childnode>
        <childnode refid="2361" relation="include">
        </childnode>
        <childnode refid="2362" relation="include">
        </childnode>
        <childnode refid="2367" relation="include">
        </childnode>
      </node>
      <node id="2357">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="strfuncs_8c_1a4c99ea339290583666e56c6b0647386e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double sb_strtod</definition>
        <argsstring>(const char *s00, char **se)</argsstring>
        <name>sb_strtod</name>
        <param>
          <type>const char *</type>
          <declname>s00</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>se</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="52" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/dtoa.c" bodystart="1545" bodyend="2296"/>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1a4f33cdc1de978989085029ad6856d53a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double atof_c</definition>
        <argsstring>(char const *str)</argsstring>
        <name>atof_c</name>
        <param>
          <type>char const *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Locale independent version of atof(). </para>        </briefdescription>
        <detaileddescription>
<para>This function behaves like atof() in the &quot;C&quot; locale. Switching locale in a threaded program is extremely uncool, therefore we need this since we pass floats as strings in 1000 different places. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="55" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="55" bodyend="58"/>
        <referencedby refid="logmath_8h_1afbed298ba0bc4736415d78880fe5c7c2" compoundref="logmath_8c" startline="164" endline="269">logmath_read</referencedby>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1ac213827cbebbe33d53c4000f6955105d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int isspace_c</definition>
        <argsstring>(char ch)</argsstring>
        <name>isspace_c</name>
        <param>
          <type>char</type>
          <declname>ch</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="62" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="62" bodyend="67"/>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1a41719aaedd048c4e26b1854558d6eed5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>char *</type>
        <definition>char* string_join</definition>
        <argsstring>(const char *base,...)</argsstring>
        <name>string_join</name>
        <param>
          <type>const char *</type>
          <declname>base</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
<para>Concatenate a NULL-terminated argument list of strings, returning a newly allocated string. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="70" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="70" bodyend="94"/>
        <references refid="ckd__alloc_8h_1aa00ef21903bc4f8a972488417adc8d2e" compoundref="ckd__alloc_8h" startline="248">ckd_calloc</references>
        <referencedby refid="jsgf_8c_1a18fc91b6b6e79fb183147502df372b5e" compoundref="jsgf_8c" startline="469" endline="481">jsgf_get_rule</referencedby>
        <referencedby refid="ngram__model__set_8c_1a1389a90bf32110fd7e56a73b6d39fa07" compoundref="ngram__model__set_8c" startline="185" endline="365">ngram_model_set_read</referencedby>
        <referencedby refid="pio_8h_1aa3d71506049eb49cf03eff1b89ef281f" compoundref="pio_8c" startline="107" endline="180">fopen_comp</referencedby>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1aeecf7c2413376fa46eeb72a94f85ca27" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>char *</type>
        <definition>char* string_trim</definition>
        <argsstring>(char *string, enum string_edge_e which)</argsstring>
        <name>string_trim</name>
        <param>
          <type>char *</type>
          <declname>string</declname>
        </param>
        <param>
          <type>enum <ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9" kindref="member">string_edge_e</ref></type>
          <declname>which</declname>
        </param>
        <briefdescription>
<para>Remove whitespace from a string, modifying it in-place. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>string</parametername>
</parameternamelist>
<parameterdescription>
<para>string to trim, contents will be modified. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>which</parametername>
</parameternamelist>
<parameterdescription>
<para>one of STRING_START, STRING_END, or STRING_BOTH. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="97" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="97" bodyend="120"/>
        <references refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a5e4d73e6ca445be10fa48351b9571125" compoundref="strfuncs_8h" startline="71">STRING_START</references>
        <references refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a4fcbb0fe16fa4aa48723ba3ba10c26dd" compoundref="strfuncs_8h" startline="73">STRING_BOTH</references>
        <references refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a11f31598e50bf3cf1d0aa97d967bb9b9" compoundref="strfuncs_8h" startline="72">STRING_END</references>
        <referencedby refid="pio_8h_1a45ce4c15a564179e9148445fe44ac482" compoundref="pio_8c" startline="288" endline="306">lineiter_start_clean</referencedby>
        <referencedby refid="pio_8h_1aff8df0b6928746d61b3520555263f71e" compoundref="pio_8c" startline="347" endline="360">lineiter_next</referencedby>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1a00840bdeb8d4605928631cdd5ffac68d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int32</type>
        <definition>int32 str2words</definition>
        <argsstring>(char *line, char **ptr, int32 max_ptr)</argsstring>
        <name>str2words</name>
        <param>
          <type>char *</type>
          <declname>line</declname>
          <briefdescription><para>In/Out: line to be parsed. This string will be modified! (NUL characters inserted at word boundaries) </para></briefdescription>
        </param>
        <param>
          <type>char **</type>
          <declname>wptr</declname>
          <defname>ptr</defname>
          <briefdescription><para>In/Out: Array of pointers to words found in line. The array must be allocated by the caller. It may be NULL in which case the number of words will be counted. This allows you to allcate it to the proper size, e.g.:</para><para>n = str2words(line, NULL, 0); wptr = <ref refid="ckd__alloc_8h_1aa00ef21903bc4f8a972488417adc8d2e" kindref="member">ckd_calloc(n, sizeof(*wptr))</ref>; str2words(line, wptr, n); </para></briefdescription>
        </param>
        <param>
          <type>int32</type>
          <declname>n_wptr</declname>
          <defname>max_ptr</defname>
          <briefdescription><para>In: Size of wptr array, ignored if wptr == NULL </para></briefdescription>
        </param>
        <briefdescription>
<para>Convert a line to an array of &quot;words&quot;, based on whitespace separators. </para>        </briefdescription>
        <detaileddescription>
<para>A word is a string with no whitespace chars in it. Note that the string line is modified as a result: NULL chars are placed after every word in the line. Return value: No. of words found; -1 if no. of words in line exceeds n_wptr. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="123" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="123" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="strfuncs_8c_1a55fce4de2d16ec4f447be58674ca606a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int32</type>
        <definition>int32 nextword</definition>
        <argsstring>(char *line, const char *delim, char **word, char *delimfound)</argsstring>
        <name>nextword</name>
        <param>
          <type>char *</type>
          <declname>line</declname>
          <briefdescription><para>Input: String being searched for next word. Will be modified by this function (NUL characters inserted) </para></briefdescription>
        </param>
        <param>
          <type>const char *</type>
          <declname>delim</declname>
          <briefdescription><para>Input: A word, if found, must be delimited at either end by a character from this string (or at the end by the NULL char) </para></briefdescription>
        </param>
        <param>
          <type>char **</type>
          <declname>word</declname>
          <briefdescription><para>Output: *word = ptr within line to beginning of first word, if found. Delimiter at the end of word replaced with the NULL char. </para></briefdescription>
        </param>
        <param>
          <type>char *</type>
          <declname>delimfound</declname>
          <briefdescription><para>Output: *delimfound = original delimiter found at the end of the word. (This way, the caller can restore the delimiter, preserving the original string.) </para></briefdescription>
        </param>
        <briefdescription>
<para>Yet another attempt at a clean &quot;next-word-in-string&quot; function. </para>        </briefdescription>
        <detaileddescription>
<para>See arguments below. <simplesect kind="return"><para>Length of word returned, or -1 if nothing found. This allows you to scan through a line:</para></simplesect>
<preformatted>
while ((n = nextword(line, delim, &amp;word, &amp;delimfound)) &gt;= 0) {
    ... do something with word ..
    word[n] = delimfound;
    line = word + n;
}
</preformatted> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" line="166" column="1" bodyfile="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c" bodystart="166" bodyend="194"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*<sp/>-*-<sp/>c-basic-offset:<sp/>4;<sp/>indent-tabs-mode:<sp/>nil<sp/>-*-<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>====================================================================</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>1999-2006<sp/>Carnegie<sp/>Mellon<sp/>University.<sp/><sp/>All<sp/>rights</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>reserved.</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/>1.<sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.<sp/></highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/>2.<sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>the<sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>distribution.</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/>This<sp/>work<sp/>was<sp/>supported<sp/>in<sp/>part<sp/>by<sp/>funding<sp/>from<sp/>the<sp/>Defense<sp/>Advanced<sp/></highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*<sp/>Research<sp/>Projects<sp/>Agency<sp/>and<sp/>the<sp/>National<sp/>Science<sp/>Foundation<sp/>of<sp/>the<sp/></highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>United<sp/>States<sp/>of<sp/>America,<sp/>and<sp/>the<sp/>CMU<sp/>Sphinx<sp/>Speech<sp/>Consortium.</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>CARNEGIE<sp/>MELLON<sp/>UNIVERSITY<sp/>``AS<sp/>IS&apos;&apos;<sp/>AND<sp/></highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>ANY<sp/>EXPRESSED<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,<sp/></highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>THE<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>PURPOSE<sp/>ARE<sp/>DISCLAIMED.<sp/><sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>CARNEGIE<sp/>MELLON<sp/>UNIVERSITY</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>NOR<sp/>ITS<sp/>EMPLOYEES<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/>SPECIAL,<sp/>EXEMPLARY,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/></highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>LIMITED<sp/>TO,<sp/>PROCUREMENT<sp/>OF<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/></highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>DATA,<sp/>OR<sp/>PROFITS;<sp/>OR<sp/>BUSINESS<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/></highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>THEORY<sp/>OF<sp/>LIABILITY,<sp/>WHETHER<sp/>IN<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/></highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR<sp/>OTHERWISE)<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/></highlight></codeline>
<codeline lineno="32"><highlight class="comment"><sp/>*<sp/>OF<sp/>THIS<sp/>SOFTWARE,<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="33"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="34"><highlight class="comment"><sp/>*<sp/>====================================================================</highlight></codeline>
<codeline lineno="35"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="36"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="38"><highlight class="comment"><sp/>*<sp/>strfuncs.c<sp/>--<sp/>String<sp/>functions</highlight></codeline>
<codeline lineno="39"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;assert.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdarg.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ckd__alloc_8h" kindref="compound">sphinxbase/ckd_alloc.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="strfuncs_8h" kindref="compound">sphinxbase/strfuncs.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Defined<sp/>in<sp/>dtoa.c<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sb_strtod(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*s00,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**se);</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="55" refid="strfuncs_8h_1ab708351fe7308551632a782bfad75a1e" refkind="member"><highlight class="normal"><ref refid="strfuncs_8h_1ab708351fe7308551632a782bfad75a1e" kindref="member">atof_c</ref>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*str)</highlight></codeline>
<codeline lineno="56"><highlight class="normal">{</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sb_strtod(str,<sp/>NULL);</highlight></codeline>
<codeline lineno="58"><highlight class="normal">}</highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Locale-independent<sp/>isspace<sp/>to<sp/>avoid<sp/>different<sp/>incompatibilities<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal">isspace_c(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>ch)</highlight></codeline>
<codeline lineno="63"><highlight class="normal">{</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>||<sp/>ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\t&apos;</highlight><highlight class="normal"><sp/>||<sp/>ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal"><sp/>||<sp/>ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\r&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="67"><highlight class="normal">}</highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*</highlight></codeline>
<codeline lineno="70" refid="strfuncs_8h_1a317522f23d291311e366de34ef86b777" refkind="member"><highlight class="normal"><ref refid="strfuncs_8h_1a317522f23d291311e366de34ef86b777" kindref="member">string_join</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*base,<sp/>...)</highlight></codeline>
<codeline lineno="71"><highlight class="normal">{</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>args;</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*c;</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*out;</highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(args,<sp/>base);</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/>len<sp/>=<sp/>strlen(base);</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((c<sp/>=<sp/>va_arg(args,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*))<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>len<sp/>+=<sp/>strlen(c);</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/>len++;</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(args);</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/>out<sp/>=<sp/><ref refid="ckd__alloc_8h_1aa00ef21903bc4f8a972488417adc8d2e" kindref="member">ckd_calloc</ref>(len,<sp/>1);</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(args,<sp/>base);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/>strcpy(out,<sp/>base);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((c<sp/>=<sp/>va_arg(args,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*))<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcat(out,<sp/>c);</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(args);</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>out;</highlight></codeline>
<codeline lineno="94"><highlight class="normal">}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*</highlight></codeline>
<codeline lineno="97" refid="strfuncs_8h_1ac36a095632a4f16cf4e0fbcdb01de5ad" refkind="member"><highlight class="normal"><ref refid="strfuncs_8h_1ac36a095632a4f16cf4e0fbcdb01de5ad" kindref="member">string_trim</ref>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9" kindref="member">string_edge_e</ref><sp/>which)</highlight></codeline>
<codeline lineno="98"><highlight class="normal">{</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/>len<sp/>=<sp/>strlen(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(which<sp/>==<sp/><ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a5e4d73e6ca445be10fa48351b9571125" kindref="member">STRING_START</ref><sp/>||<sp/>which<sp/>==<sp/><ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a4fcbb0fe16fa4aa48723ba3ba10c26dd" kindref="member">STRING_BOTH</ref>)<sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>sub<sp/>=<sp/>strspn(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>\t\n\r\f&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sub<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>+<sp/>sub,<sp/>len<sp/>+<sp/>1<sp/>-<sp/>sub);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>len<sp/>-=<sp/>sub;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(which<sp/>==<sp/><ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a11f31598e50bf3cf1d0aa97d967bb9b9" kindref="member">STRING_END</ref><sp/>||<sp/>which<sp/>==<sp/><ref refid="strfuncs_8h_1ab5c9ca15770a4bd3047705762b815df9a4fcbb0fe16fa4aa48723ba3ba10c26dd" kindref="member">STRING_BOTH</ref>)<sp/>{</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>sub<sp/>=<sp/>len;</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(--sub<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strchr(</highlight><highlight class="stringliteral">&quot;<sp/>\t\n\r\f&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">[sub])<sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sub<sp/>==<sp/>-1)</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">[0]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">string</highlight><highlight class="normal">[sub+1]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>string;</highlight></codeline>
<codeline lineno="120"><highlight class="normal">}</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal">int32</highlight></codeline>
<codeline lineno="123" refid="strfuncs_8h_1a5b520fdebcca599db86faaf75a82173f" refkind="member"><highlight class="normal"><ref refid="strfuncs_8h_1a5b520fdebcca599db86faaf75a82173f" kindref="member">str2words</ref>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*line,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**ptr,<sp/>int32<sp/>max_ptr)</highlight></codeline>
<codeline lineno="124"><highlight class="normal">{</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/>int32<sp/>i,<sp/>n;</highlight></codeline>
<codeline lineno="126"><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>#words<sp/>found<sp/>so<sp/>far<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/>i<sp/>=<sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>For<sp/>scanning<sp/>through<sp/>the<sp/>input<sp/>string<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Skip<sp/>whitespace<sp/>before<sp/>next<sp/>word<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(line[i]<sp/>&amp;&amp;<sp/>isspace_c(line[i]))</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!line[i])</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>!=<sp/>NULL<sp/>&amp;&amp;<sp/>n<sp/>&gt;=<sp/>max_ptr)<sp/>{</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>Pointer<sp/>array<sp/>size<sp/>insufficient.<sp/><sp/>Restore<sp/>NULL<sp/>chars<sp/>inserted<sp/>so<sp/>far</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>to<sp/>space<sp/>chars.<sp/><sp/>Not<sp/>a<sp/>perfect<sp/>restoration,<sp/>but<sp/>better<sp/>than<sp/>nothing.</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>i<sp/>&gt;=<sp/>0;<sp/>--i)</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(line[i]<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>line[i]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Scan<sp/>to<sp/>end<sp/>of<sp/>word<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr[n]<sp/>=<sp/>line<sp/>+<sp/>i;</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++n;</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(line[i]<sp/>&amp;&amp;<sp/>!isspace_c(line[i]))</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!line[i])</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>line[i]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++i;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="162"><highlight class="normal">}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal">int32</highlight></codeline>
<codeline lineno="166" refid="strfuncs_8h_1a41d9a59e4326b545bf1282401319f553" refkind="member"><highlight class="normal"><ref refid="strfuncs_8h_1a41d9a59e4326b545bf1282401319f553" kindref="member">nextword</ref>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*line,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*delim,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**word,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*delimfound)</highlight></codeline>
<codeline lineno="167"><highlight class="normal">{</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*d;</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*w;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Skip<sp/>past<sp/>any<sp/>preceding<sp/>delimiters<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(w<sp/>=<sp/>line;<sp/>*w;<sp/>w++)<sp/>{</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(d<sp/>=<sp/>delim;<sp/>*d<sp/>&amp;&amp;<sp/>(*d<sp/>!=<sp/>*w);<sp/>d++);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!*d)</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!*w)</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/>*word<sp/>=<sp/>w;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Beginning<sp/>of<sp/>word<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Skip<sp/>until<sp/>first<sp/>delimiter<sp/>char<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(w++;<sp/>*w;<sp/>w++)<sp/>{</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(d<sp/>=<sp/>delim;<sp/>*d<sp/>&amp;&amp;<sp/>(*d<sp/>!=<sp/>*w);<sp/>d++);</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*d)</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Replace<sp/>delimiter<sp/>with<sp/>NULL<sp/>char,<sp/>but<sp/>return<sp/>the<sp/>original<sp/>first<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/>*delimfound<sp/>=<sp/>*w;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/>*w<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(w<sp/>-<sp/>*word);</highlight></codeline>
<codeline lineno="194"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/scratch/cluster/rcorona/nlu_pipeline/src/speech/libs/sphinxbase/src/libsphinxbase/util/strfuncs.c"/>
  </compounddef>
</doxygen>
